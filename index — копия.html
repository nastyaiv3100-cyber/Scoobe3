<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>fdrt</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: "Roboto Condensed", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: url("https://img.genially.com/684ea2da1b51060014c50e97/02a82270-d1cd-454d-aff9-078ff614eafb.png") center/cover no-repeat;
        }
        
        #hero {
            position: absolute;
            bottom: 30px;
            width: 120px;
            height: 150px;
            background: url("https://img.genially.com/684ea2da1b51060014c50e97/2ee0c1c5-ce22-4c19-983b-04aaf9f9b323.png") center/contain no-repeat;
            transform-origin: center bottom;
            transition: transform 0.15s linear;
        }
        
        .falling {
            position: absolute;
            top: -120px;
            width: 80px;
            height: 80px;
            background-size: contain;
            background-repeat: no-repeat;
            will-change: transform, top;
        }

        .gift {}

        .bomb {
            width: 60px;
            height: 60px;
            background-image: url("https://img.genially.com/684ea2da1b51060014c50e97/779cc56a-4b19-4157-ada9-cf32f4839d51.png");
        }

        .candy {
            width: 70px;
            height: 70px;
            background-image: url("https://img.genially.com/684ea2da1b51060014c50e97/9093b598-60a3-4841-bab4-83e646ee8eb9.png");
        }

        .word-label {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: #000000;
            font-weight: 700;
            text-shadow: 0 0 4px rgba(0,0,0,0.7);
            white-space: nowrap;
            font-family: "Roboto Condensed", sans-serif;
        }
        
        #score-board {
            position: absolute;
            top: 10px;
            left: 15px;
            display: flex;
            gap: 12px;
            z-index: 10;
            font-family: "Roboto Condensed", sans-serif;
        }

        .ui-box {
            padding: 6px 12px;
            border-radius: 10px;
            background: rgba(0,0,0,0.6);
            border: 2px solid rgba(200,120,255,0.9);
            box-shadow:
                0 0 6px rgba(160,70,255,0.9),
                0 0 14px rgba(220,160,255,0.9);
            color: #f3d8ff;
            font-size: 18px;
        }

        .ui-box label {
            opacity: 0.85;
            margin-right: 4px;
        }
        
        .floating-score {
            position: absolute;
            color: #ffe98a;
            font-weight: 700;
            font-size: 22px;
            text-shadow: 0 0 6px rgba(255,215,0,0.9);
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            font-family: "Roboto Condensed", sans-serif;
        }
        @keyframes floatUp {
            0%   { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); }
        }
        
        .burst {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            animation: burstAnim 0.4s ease-out forwards;
        }
        .burst.gold {
            background: radial-gradient(circle, rgba(255,255,200,0.9), rgba(255,215,0,0.1));
            box-shadow: 0 0 18px rgba(255,215,0,0.9);
        }
        .burst.black {
            background: radial-gradient(circle, rgba(60,60,60,0.95), rgba(0,0,0,0.1));
            box-shadow: 0 0 18px rgba(0,0,0,0.9);
        }
        @keyframes burstAnim {
            0%   { opacity: 0.9; transform: scale(0.2); }
            100% { opacity: 0;   transform: scale(1.4); }
        }
        
        @keyframes shake {
            0%  { transform: translateX(0) scale(var(--hero-scale, 1)) scaleX(1); }
            20% { transform: translateX(-8px) scale(var(--hero-scale, 1)) scaleX(1); }
            40% { transform: translateX(8px)  scale(var(--hero-scale, 1)) scaleX(1); }
            60% { transform: translateX(-6px) scale(var(--hero-scale, 1)) scaleX(1); }
            80% { transform: translateX(6px)  scale(var(--hero-scale, 1)) scaleX(1); }
            100%{ transform: translateX(0)  scale(var(--hero-scale, 1)) scaleX(1); }
        }
        .shaking {
            animation: shake 0.5s linear 0s 3;
        }
        
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .overlay-content {
            position: relative;
            min-width: 360px;
            padding: 30px 40px 30px;
            border-radius: 20px;
            background: rgba(5,5,5,0.85);
            border: 3px solid rgba(255,215,0,0.9);
            box-shadow:
                0 0 25px rgba(255,215,0,0.7),
                0 0 80px rgba(0,0,0,0.9);
            text-align: center;
            color: #ffeeb3;
            font-family: "Roboto Condensed", sans-serif;
        }

        .overlay h1 {
            margin-bottom: 20px;
            font-size: 36px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 12px rgba(255,215,0,0.9);
        }

        .overlay p {
            margin-bottom: 20px;
            font-size: 18px;
        }

        .overlay button {
            margin-top: 5px;
            padding: 10px 25px;
            font-size: 18px;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            background: linear-gradient(135deg, #ffe98a, #ffcc33);
            color: #4a3200;
            font-weight: 700;
            box-shadow: 0 0 12px rgba(255,215,0,0.8);
            transition: transform 0.1s, box-shadow 0.1s;
            font-family: "Roboto Condensed", sans-serif;
        }
        .overlay button:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 0 18px rgba(255,215,0,1);
        }
        .overlay button:active {
            transform: translateY(1px) scale(0.98);
            box-shadow: 0 0 8px rgba(255,215,0,0.7);
        }
        
        #start-overlay .overlay-content {
            border-color: rgba(180,130,255,0.9);
            box-shadow:
                0 0 25px rgba(180,130,255,0.9),
                0 0 80px rgba(0,0,0,0.9);
        }
        #start-overlay h1 {
            text-shadow: 0 0 14px rgba(190,140,255,0.95);
        }
        #start-overlay button {
            background: linear-gradient(135deg, #d6b3ff, #974dff);
            color: #1b0a33;
            box-shadow:
                0 0 12px rgba(190,140,255,0.95),
                0 0 20px rgba(190,140,255,0.75);
        }
        
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,215,0,0.95);
            box-shadow: 0 0 10px rgba(255,215,0,1);
            animation: firework 1.1s ease-out forwards;
            pointer-events: none;
        }
        @keyframes firework {
            0% {
                opacity: 1;
                transform: translate(0,0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--dx), var(--dy)) scale(0.2);
            }
        }
    </style>
</head>
<body>
<div id="game-container">
    <div id="start-overlay" class="overlay" style="display:flex;">
        <div class="overlay-content">
            <h1>Поймай маршмеллоу</h1>
            <p>Используй ← → or A / D поймай правильные ответы<br>
               Избегай горелых маршмеллоу и неправильных ответов. Поймай сэндвич, чтобы получить дополнительные очки!</p>
            <button id="start-btn">Поймать!</button>
        </div>
    </div>

    <div id="score-board">
        <div class="ui-box">
            <label>Score:</label><span id="score">0</span>
        </div>
        <div class="ui-box">
            <label>Errors:</label><span id="errors">0</span> / 3
        </div>
    </div>

    <div id="hero"></div>
    
    <div id="game-over-overlay" class="overlay">
        <div class="overlay-content">
            <h1>Игра закончилась</h1>
            <p>Ну нет!</p>
            <button id="retry-btn">Попробовать снова?</button>
        </div>
    </div>
    
    <div id="win-overlay" class="overlay">
        <div class="overlay-content">
            <h1>Получилось!</h1>
            <p>Ты поймал все маршмеллоу!</p>
            <button id="play-again-btn">Попробовать снова?</button>
        </div>
    </div>
</div>

<script>
    const CORRECT_WORDS = ["70", "70", "70","70"];
    const WRONG_WORDS   = ["12", "94", "36", "49"];

    const MAX_ERRORS = 3;
    const HERO_SPEED = 4;

    const FALL_SPEED_BASE = 0.9;
    const FALL_SPEED_RAND = 0.5;

    const SPAWN_INTERVAL = 200;

    const MIN_HORIZONTAL_GAP = 100;
    const SIDE_MARGIN = 150;

    const HERO_SCALE = 1.5;
    const WORD_FONT_SIZE = 28;

    const MAX_ON_SCREEN = 2;
    
    const game = document.getElementById("game-container");
    const heroEl = document.getElementById("hero");
    const scoreEl = document.getElementById("score");
    const errorsEl = document.getElementById("errors");

    const gameOverOverlay = document.getElementById("game-over-overlay");
    const winOverlay = document.getElementById("win-overlay");
    const startOverlay = document.getElementById("start-overlay");
    const startBtn = document.getElementById("start-btn");
    const retryBtn = document.getElementById("retry-btn");
    const playAgainBtn = document.getElementById("play-again-btn");
    
    let heroX = 0;
    let heroWidthBase = 120;
    let heroWidth = heroWidthBase * HERO_SCALE;
    let heroFlipped = false;

    let score = 0;
    let errors = 0;

    let activeObjects = []; // {el,x,y,speed,type,word?,isCorrect?}
    let keys = { left:false, right:false };

    let gameRunning = false;
    let spawnTimer = null;
    let lastTime = performance.now();
    let correctCaught = 0;
    const correctNeed = CORRECT_WORDS.length;

    let bombHitLock = false;

    let availableCorrectWords = [];
    let availableWrongWords = [];

    const PATTERNS = [
        ["wrong", "candy", "bomb", "correct", "wrong"],
        ["wrong", "bomb", "candy", "wrong", "correct"],
        ["candy", "wrong", "bomb", "correct"],
        ["wrong", "bomb", "candy", "correct", "wrong"],
        ["bomb", "wrong", "candy", "correct"],
        ["candy", "wrong", "bomb", "wrong", "correct"]
    ];
    let currentPattern = [];
    let patternIndex = 0;

    let canSpawnNext = true;
    
    function setupHeroScale() {
        heroEl.style.setProperty('--hero-scale', HERO_SCALE);
    }
    function updateHeroTransform() {
        const scaleX = heroFlipped ? -1 : 1;
        heroEl.style.transform = `scale(${HERO_SCALE}) scaleX(${scaleX})`;
    }
    
    function chooseRandomPattern() {
        const idx = Math.floor(Math.random() * PATTERNS.length);
        currentPattern = PATTERNS[idx].slice();
        patternIndex = 0;
    }
    function getNextTypeFromPattern() {
        if (currentPattern.length === 0 || patternIndex >= currentPattern.length) {
            chooseRandomPattern();
        }
        const t = currentPattern[patternIndex];
        patternIndex++;
        return t;
    }
    
    function initGameState() {
        const rect = game.getBoundingClientRect();
        heroWidth = heroWidthBase * HERO_SCALE;
        heroX = (rect.width - heroWidth) / 2;
        updateHeroPosition();

        score = 0;
        errors = 0;
        correctCaught = 0;

        activeObjects.forEach(o => o.el.remove());
        activeObjects = [];

        availableCorrectWords = [...CORRECT_WORDS];
        availableWrongWords = [...WRONG_WORDS];

        scoreEl.textContent = score;
        errorsEl.textContent = errors;

        canSpawnNext = true;
        chooseRandomPattern();

        spawnNextByPattern(); 
        canSpawnNext = false;
    }

    function startGame() {
        initGameState();
        hideOverlay(gameOverOverlay);
        hideOverlay(winOverlay);
        hideOverlay(startOverlay);

        gameRunning = true;
        lastTime = performance.now();

        clearInterval(spawnTimer);
        spawnTimer = setInterval(() => {
            if (!gameRunning) return;
            if (canSpawnNext && activeObjects.length < MAX_ON_SCREEN) {
                spawnNextByPattern();
                canSpawnNext = false;
            }
        }, SPAWN_INTERVAL);

        requestAnimationFrame(gameLoop);
    }
   
    function updateHeroPosition() {
        const rect = game.getBoundingClientRect();
        const minX = SIDE_MARGIN;
        const maxX = rect.width - heroWidth - SIDE_MARGIN;

        if (heroX < minX) {
            heroX = minX;
            heroFlipped = false;
        }
        if (heroX > maxX) {
            heroX = maxX;
            heroFlipped = true;
        }
        heroEl.style.left = heroX + "px";
        updateHeroTransform();
    }
    
    function spawnNextByPattern() {
        const type = getNextTypeFromPattern();
        const rect = game.getBoundingClientRect();

        if (type === "correct") {
            spawnGift(rect, true);
        } else if (type === "wrong") {
            spawnGift(rect, false);
        } else if (type === "bomb") {
            spawnBomb(rect);
        } else if (type === "candy") {
            spawnCandy(rect);
        }
    }

    function getNonOverlappingX(width) {
        const rect = game.getBoundingClientRect();
        const maxAttempts = 30;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const minX = SIDE_MARGIN;
            const maxX = rect.width - width - SIDE_MARGIN;
            const x = Math.random() * (maxX - minX) + minX;
            let overlaps = false;

            for (const obj of activeObjects) {
                const otherWidth = obj.el.offsetWidth || 80;
                const otherLeft = obj.x;
                const otherRight = obj.x + otherWidth;
                const thisLeft = x;
                const thisRight = x + width;

                const horizontalOverlap =
                    thisRight + MIN_HORIZONTAL_GAP > otherLeft &&
                    thisLeft - MIN_HORIZONTAL_GAP < otherRight;

                if (horizontalOverlap) {
                    overlaps = true;
                    break;
                }
            }

            if (!overlaps) return x;
        }
        const minX = SIDE_MARGIN;
        const maxX = rect.width - width - SIDE_MARGIN;
        return Math.random() * (maxX - minX) + minX;
    }
    
    function spawnGift(rect, onlyCorrect) {
        if (onlyCorrect && availableCorrectWords.length === 0) return;
        if (!onlyCorrect && availableWrongWords.length === 0) return;

        const el = document.createElement("div");
        el.classList.add("falling", "gift");

        const giftImg = Math.random() < 0.5
            ? "https://img.genially.com/684ea2da1b51060014c50e97/3ef135c8-35c7-41a0-ab55-97b9142ac576.png"
            : "https://img.genially.com/684ea2da1b51060014c50e97/f7111a88-851c-4123-9ebc-acffe0cb16a3.png";
        el.style.backgroundImage = `url("${giftImg}")`;

        const width = 80;
        const x = getNonOverlappingX(width);
        el.style.left = x + "px";

        let word;
        let isCorrect;
        if (onlyCorrect) {
            const idx = Math.floor(Math.random() * availableCorrectWords.length);
            word = availableCorrectWords.splice(idx, 1)[0];
            isCorrect = true;
        } else {
            const idx = Math.floor(Math.random() * availableWrongWords.length);
            word = availableWrongWords.splice(idx, 1)[0];
            isCorrect = false;
        }

        const label = document.createElement("div");
        label.classList.add("word-label");
        label.textContent = word;
        label.style.fontSize = WORD_FONT_SIZE + "px";
        el.appendChild(label);

        game.appendChild(el);

        const obj = {
            el,
            x,
            y: -100,
            speed: FALL_SPEED_BASE + Math.random() * FALL_SPEED_RAND,
            type: "gift",
            word,
            isCorrect
        };
        activeObjects.push(obj);
    }

    function spawnBomb(rect) {
        const el = document.createElement("div");
        el.classList.add("falling", "bomb");
        const width = 60;
        const x = getNonOverlappingX(width);
        el.style.left = x + "px";
        game.appendChild(el);

        activeObjects.push({
            el,
            x,
            y: -80,
            speed: FALL_SPEED_BASE + Math.random() * FALL_SPEED_RAND + 0.2,
            type: "bomb"
        });
    }

    function spawnCandy(rect) {
        const el = document.createElement("div");
        el.classList.add("falling", "candy");
        const width = 70;
        const x = getNonOverlappingX(width);
        el.style.left = x + "px";
        game.appendChild(el);

        activeObjects.push({
            el,
            x,
            y: -80,
            speed: FALL_SPEED_BASE + Math.random() * FALL_SPEED_RAND,
            type: "candy"
        });
    }
    
    function gameLoop(time) {
        if (!gameRunning) return;

        const dt = (time - lastTime) / 16.67;
        lastTime = time;

        if (keys.left) {
            heroX -= HERO_SPEED * dt;
        }
        if (keys.right) {
            heroX += HERO_SPEED * dt;
        }
        updateHeroPosition();

        updateObjects(dt);
        requestAnimationFrame(gameLoop);
    }

    function updateObjects(dt) {
        const rect = game.getBoundingClientRect();
        const heroRect = heroEl.getBoundingClientRect();
        const gameRect = game.getBoundingClientRect();

        const heroLeft = heroRect.left - gameRect.left;
        const heroRight = heroRect.right - gameRect.left;
        const heroTop = heroRect.top - gameRect.top;
        const heroBottom = heroRect.bottom - gameRect.top;

        const triggerY = rect.height / 3;

        let anyReachedThird = false;

        for (let i = activeObjects.length - 1; i >= 0; i--) {
            const obj = activeObjects[i];
            obj.y += obj.speed * dt;
            obj.el.style.top = obj.y + "px";
            obj.x = parseFloat(obj.el.style.left) || obj.x;

            if (obj.y >= triggerY) {
                anyReachedThird = true;
            }

            if (obj.y > rect.height + 120) {
                obj.el.remove();
                activeObjects.splice(i, 1);
            if (obj.type === "gift" && obj.isCorrect) {
        checkWinCondition();
    }
            continue;
            }

            const objRect = obj.el.getBoundingClientRect();
            const oLeft = objRect.left - gameRect.left;
            const oRight = objRect.right - gameRect.left;
            const oTop = objRect.top - gameRect.top;
            const oBottom = objRect.bottom - gameRect.top;

            const intersect =
                oRight > heroLeft &&
                oLeft < heroRight &&
                oBottom > heroTop &&
                oTop < heroBottom;

            if (intersect) {
                handleCollision(obj, i, (heroLeft + heroRight) / 2, heroTop);
            }
        }

        if (anyReachedThird && activeObjects.length < MAX_ON_SCREEN) {
            canSpawnNext = true;
        }

        if (activeObjects.length === 0) {
            canSpawnNext = true;
        }
    }
    
    function handleCollision(obj, index, centerX, heroTop) {
        if (obj.type === "gift") {
            if (obj.isCorrect) {
                score += 10;
                scoreEl.textContent = score;
                correctCaught++;
                createBurst(centerX, heroTop, "gold");
                createFloatingScore("+10", centerX, heroTop - 20);
                obj.el.remove();
                activeObjects.splice(index, 1);
                checkWinCondition();
            } else {
                errors++;
                errorsEl.textContent = errors;
                createBurst(centerX, heroTop, "black");
                obj.el.remove();
                activeObjects.splice(index, 1);
                if (errors >= MAX_ERRORS) {
                    endGame(false);
                }
            }
        } else if (obj.type === "bomb") {
            if (!bombHitLock) {
                bombHitLock = true;
                heroEl.classList.add("shaking");
                setTimeout(() => {
                    heroEl.classList.remove("shaking");
                    bombHitLock = false;
                }, 1500);
            }
            createBurst(centerX, heroTop, "black");
            obj.el.remove();
            activeObjects.splice(index, 1);
        } else if (obj.type === "candy") {
            score += 5;
            scoreEl.textContent = score;
            createBurst(centerX, heroTop, "gold");
            createFloatingScore("+5", centerX, heroTop - 20);
            obj.el.remove();
            activeObjects.splice(index, 1);
        }
    }
    
    function createFloatingScore(text, x, y) {
        const el = document.createElement("div");
        el.classList.add("floating-score");
        el.textContent = text;
        el.style.left = x + "px";
        el.style.top = y + "px";
        game.appendChild(el);
        setTimeout(() => el.remove(), 1100);
    }

    function createBurst(x, y, color) {
        const el = document.createElement("div");
        el.classList.add("burst");
        if (color === "gold") el.classList.add("gold");
        if (color === "black") el.classList.add("black");
        el.style.left = (x - 40) + "px";
        el.style.top = (y - 40) + "px";
        game.appendChild(el);
        setTimeout(() => el.remove(), 450);
    }

    function createFireworks() {
        const rect = game.getBoundingClientRect();
        const count = 80;
        for (let i = 0; i < count; i++) {
            const baseX = Math.random() * rect.width;
            const baseY = Math.random() * rect.height;
            const sparks = 10;
            for (let j = 0; j < sparks; j++) {
                const f = document.createElement("div");
                f.classList.add("firework");
                f.style.left = baseX + "px";
                f.style.top = baseY + "px";
                const angle = (Math.PI * 2 * j) / sparks;
                const dist = 40 + Math.random() * 40;
                f.style.setProperty("--dx", Math.cos(angle) * dist + "px");
                f.style.setProperty("--dy", Math.sin(angle) * dist + "px");
                game.appendChild(f);
                setTimeout(() => f.remove(), 1200);
            }
        }
    }
    
    function checkWinCondition() {
        const noMoreCorrectInPool = availableCorrectWords.length === 0;
        const noMoreCorrectOnScreen = !activeObjects.some(o => o.type === "gift" && o.isCorrect);
        if (noMoreCorrectInPool && noMoreCorrectOnScreen) {
        endGame(true);
        }
    }

    function endGame(win) {
        gameRunning = false;
        clearInterval(spawnTimer);

        if (win) {
            showOverlay(winOverlay);
            createFireworks();
        } else {
            showOverlay(gameOverOverlay);
        }
    }

    function showOverlay(overlay) {
        overlay.style.display = "flex";
    }

    function hideOverlay(overlay) {
        overlay.style.display = "none";
    }
    
    window.addEventListener("keydown", (e) => {
        const key = (e.key || "").toLowerCase();
        if (e.code === "ArrowLeft" || key === "a") {
            keys.left = true;
        } else if (e.code === "ArrowRight" || key === "d") {
            keys.right = true;
        }
    });

    window.addEventListener("keyup", (e) => {
        const key = (e.key || "").toLowerCase();
        if (e.code === "ArrowLeft" || key === "a") {
            keys.left = false;
        } else if (e.code === "ArrowRight" || key === "d") {
            keys.right = false;
        }
    });
    
    startBtn.addEventListener("click", startGame);
    retryBtn.addEventListener("click", startGame);
    playAgainBtn.addEventListener("click", startGame);
   
    window.addEventListener("load", () => {
        setupHeroScale();
        updateHeroTransform();
    });
    window.addEventListener("resize", () => {
        updateHeroPosition();
    });
</script>
</body>
</html>